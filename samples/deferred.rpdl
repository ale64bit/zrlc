module deferred

const kLightCount = 6
const kAmbient = 0.0

type Light {
  position: vec4
  color: vec3
  radius: float
}

type Camera {
  projView: mat4
}

type PerMaterial {
  samplerColor: sampler2D 
  samplerNormalMap: sampler2D 
}

type PerObject {
  model: mat4
}

type Environment {
  lights: [kLightCount]Light
  viewPos: vec4
}

type GBuffer {
  samplerPosition: sampler2D 
  samplerNormal: sampler2D 
  samplerAlbedo: sampler2D 
}

pipeline GBufferPass(cam: Camera, perMat: PerMaterial, perObj: PerObject) {

  def vertex(pos: vec4, uv: vec2, color: vec3, normal: vec3): (vec3, vec2, vec3, vec3) {
    var worldPos = vec3(perObj.model * pos)
    builtin.position = cam.projView * perObj.model * pos
    return normal, uv, color, worldPos
  }

  def fragment(normal: vec3, uv: vec2, color, worldPos: vec3): (vec4, vec4, vec4) {
    var tbn = F(normal, tangent) # assume F is a helper pure func
    var tnorm = tbn * normalize(texture(perMat.samplerNormalMap, uv).xyz * 2 - vec3(1.0))

    var pos = vec4(worldPos, 1.0)
    var normal = vec4(tnorm, 1.0)
    var albedo = texture(perMat.samplerColor, uv)
    
    return pos, normal, albedo
  }
}

pipeline DeferredPass(gbuffer: GBuffer, env: Environment) {

  # Some helper func, not bound to any particular stage
  def contribution(l: Light): vec3 { return l.color }

  def vertex(): vec2 {
    builtin.position = vec4(uv*2.0 - 1.0, 0.0, 1.0)
    return vec2((builtin.vertexIndex << 1) & 2, builtin.vertexIndex & 2)
  }

  def fragment(uv: vec2): vec4 {
    # Get G-Buffer values
    var fragPos = texture(gbuffer.samplerPosition, uv).rgb
    var normal = texture(gbuffer.samplerNormal, uv).rgb
    var albedo = texture(gbuffer.samplerAlbedo, uv)
    
    var fragColor = albedo.rgb * kAmbient
    for l in env.lights {
      fragColor += contribution(l, fragPos, normal, ...)
    }

    return vec4(fragColor, 1.0)
  }
}

renderer Main(lights, camera: single, opaqueGeometry: set, depth: dsrt, screen: crt) {
  var black = vec3(0.0)
  var position, normal, albedo = crt(black), crt(black), crt(black)
  for g in opaqueGeometry {
    position, normal, albedo += GBufferPass(
        pos = g,
        uv = g,
        color = g,
        normal = g,
        cam = camera,
        perMat = g,
        perObj = g,
    )
  }
  screen += DeferredPass(
      gbuffer = {position, normal, albedo},
      env = {camera, lights},
  )
}
